package cn.madf.leetCode;

/**
 * tag: 动态规划
 * <p>
 * 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
 * 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。
 * 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？
 * <p>
 * 示例 1：
 * <p>
 * 输入：N = 10, K = 1, W = 10
 * 输出：1.00000
 * 说明：爱丽丝得到一张卡，然后停止。
 * <p>
 * 示例 2：
 * <p>
 * 输入：N = 6, K = 1, W = 10
 * 输出：0.60000
 * 说明：爱丽丝得到一张卡，然后停止。
 * 在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
 * <p>
 * 示例 3：
 * <p>
 * 输入：N = 21, K = 17, W = 10
 * 输出：0.73278
 * <p>
 * 提示：
 * 0 <= K <= N <= 10000
 * 1 <= W <= 10000
 * 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。
 * 此问题的判断限制时间已经减少。
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/new-21-game
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 *
 * <p>
 * 解：
 * 假设爱丽丝最终分数不超过N，代表她赢得这局游戏
 * 细心就会发现爱丽丝此刻的获胜概率只和刚刚抽牌前的分数有关，于是我们有 dp(x) = 1/W * (dp(x-1)+dp(x-2)+...+dp(x-W))
 * 题目要我们求得是爱丽丝开始时的胜率，也就是dp(0)，因此还需要将上面的动态转换方程稍作修改：
 * ......dp(x) = 1/W * (dp(x+1)+dp(x+2)+...+dp(x+W))  （我们可以将其理解成抽牌前的胜率等于抽牌后各种情况的胜率和的1/W）
 * 很明显的一道动态规划题，设最终分数为x，则明显 K <= x <= K+W-1
 * 1.   如果 N < K, 爱丽丝不可能获胜
 * 2.   如果 N > K+W-1, 爱丽丝总能获胜
 * 3.   对于 K <= x <= N 部分，爱丽丝也是总能获胜
 * 对于 N+1 <= x <= K+W-1 部分，爱丽丝不可能获胜
 * 据此，我们可以根据动态转换方程递推出dp(0)的值
 * <p>
 * 优化：转移方程中很明显计算dp(x)和dp(x-1)时，方程右边有大量重复计算，因此可以使用差分抵消掉重复计算部分
 * ......dp(x) - dp(x - 1) = 1 / W * (dp(x + W) - dp(x)), 则：
 * ......dp(x - 1) = 1 / W * ((W + 1) * dp(x) - dp(x + W))
 * 但是此时 x = K 时，dp(K + W) 不存在，因此需要单独计算dp(K - 1)；
 *
 * @author 烛影鸾书
 * @date 2020/6/3
 * @copyright© 2020
 */
public class P837_New21PointGame {
    public double new21Game(int N, int K, int W) {
        if (N < K) {
            return 0;
        } else if (N > K + W - 1 || K == 0) {
            return 1;
        }
        double[] dp = new double[K + W];
        /* 初始化 */
        for (int i = K; i < K + W; i++) {
            if (i <= N) {
                dp[i] = 1;
            } else {
                dp[i] = 0;
            }
        }

        dp[K - 1] = 1.0 * (N - K + 1) / W;

        /* 递推, 求dp(x+1)+dp(x+2)+...+dp(x+W)的过程可以优化一下，没必要每次循环求解
         * 哭了，干嘛在这儿优化，很明显状态转移方程会有重复计算之处，可以在转移方程优化的 */
        for (int i = K - 2; i >= 0; i--) {
            dp[i] = ((W + 1) * dp[i + 1] - dp[i + 1 + W]) / W;
        }
        return dp[0];
    }

    public static void main(String[] args) {
        P837_New21PointGame p837 = new P837_New21PointGame();
        System.out.println(p837.new21Game(0, 0, 1));
    }
}
